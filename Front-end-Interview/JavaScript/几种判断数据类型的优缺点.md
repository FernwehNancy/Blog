## 几种判断数据类型的优缺点

* typeof

  > 判断数据类型，一般分为基本类型和引用类型，基本类型：undefined，null，string，number，boolean，symbol，而引用类型：object，function

```javascript
typeof "hello"; //string;
typeof 123; //number
typeof c; //undefined(表示未定义)
typeof false; //boolean
let e=Symbol();
typeof e; //symbol(es6新增的数据类型，表示是独一无二，不用担心被同样的变量名覆盖)

typeof null; //object(注意这个，并不是返回null，这也是用typeof判断类型的缺点之一)
typeof [1,2,4]; //object 
typeof {id:1,name:'hello'}; //object
typeof function(){}; //function
```

这就是typeof的特点，能够判断常见的类型，但有个缺点，正如我上面提到“注意”，像null，数组都不能判断是null或者数组，然后就有第二种，看下面



* instanceof

> instanceof是用于检测某个实例对象是否是构造函数的prototype属性，由于在js中一切对象都有prototype属性，我们可以利用这个概念来判断

```javascript
[1,2,3,4] instanceof Array; //true
let a={id:1,name:'hello'};
a instanceof Array; //false
a instanceof Object; //true
```

看起来可以区分判断数组，对象的类型，但我们再来看看用基本类型判断会怎样呢？

```javascript
1 instanceof Number; //false
"hello" instanceof String; //false
false instanceof Boolean; //false
```

诶？居然不行，这就是缺点，因为instanof只能在实例上调用的，而基本类型不行，如果非要像这种，就需要通过new来实例化，比如说：

```javascript
new Number(1) instanceof Number; //true
new String('hello') instanceof String; //true
new Boolean(false) instanceof Boolean; //true
```

就是酱紫～，然后第三种：

* Object.prototype.toString.call()

> 这个可以说是比较完美的方案，能够明确判断类型，连数组，null都能判断出来的

```javascript
Object.prototype.toString.call('hello'); //[object String]
Object.prototype.toString.call(123); //[object Number]
Object.prototype.toString.call(false); //[object Boolean]
Object.prototype.toString.call(null); //[object Null]
Object.prototype.toString.call([1,2,3]); //[object Array]
Object.prototype.toString.call({id:1,name:'hello'}); //[object Object]
Object.prototype.toString.call(function(){}); //[object Function]
Object.prototype.toString.call(Symbol()); //[object Symbol]
```

每个类型都能判断出来，要说缺点，那就是写代码有点多，不过用封装函数解决就不成问题的，如下面：

```javascript
function checkType(obj){
  return Object.prototype.toString.call(obj);
}
checkType('hello'); //[object String]
```

就是酱紫～